#!/usr/bin/env perl
package Maff::Utility::AyudanteLobo;

use strict;

use Cwd; use POSIX;
use Date::Format qw/time2str/;
use Net::SSH2; use Try::Tiny;
use POE; use POE::Component::DirWatch::WithCaller;
use Unix::PID; use YAML;

use Maff::Common::OSX qw/:all/;

my $ME = "ayudante-lobo";
my $VERSION = "0.9.5";
my $HOSTNAME = `hostname`; chomp $HOSTNAME;

my ($base, $Conf);

my $running = 0;
my $sighup = 0;

# Functions included from github:MaffC/maffpl to reduce dependencies on non-CPAN modules
sub scp_upload {
	my $file = shift; my $ssh = Net::SSH2->new();
	try {
		$ssh->connect($Conf->{upload}->{server},$Conf->{upload}->{port},Timeout => 3);
	} catch {
		logger(2,"SSH connection failed (exception): $_") and return 0;
	};
	logger(2,"SSH connection failed (error): $ssh->error") and return 0 if $ssh->error;
	$ssh->auth_publickey($Conf->{upload}->{user},$Conf->{upload}->{sshkeypath}.'.pub',$Conf->{upload}->{sshkeypath});
	logger(2,"SSH connection failed (auth error): $ssh->error") and return 0 unless $ssh->auth_ok;
	$Conf->{upload}->{remotepath} .= "/" unless $Conf->{upload}->{remotepath} =~ /\/$/;
	logger(2,"File upload failed: $ssh->error") and return 0 unless $ssh->scp_put("$file",$Conf->{upload}->{remotepath}.$file->basename);
	$ssh->disconnect; return 1;
}
sub timefmt2str {
	return Date::Format::time2str(shift,time());
}

# Functions
sub init {
	#Expects that it will be launched either in an environment where $HOME is an exported env variable or that it will be launched by an initscript with the current working directory being the user's homedir. conf file location can be manually set by passing it in the LOBORC env variable.
	$base = $ENV{HOME} || cwd();
	my $confp = $ENV{LOBORC} || "$base/.${ME}rc"; my $loaded = 0;
	$loaded = init_conf($confp) if -e $confp and -f $confp and -r $confp and not -z $confp;
	if ($Conf->{general}->{storelogs} or not $loaded) {
		open(STDOUT, ">>".$Conf->{general}->{logfile}) if length $Conf->{general}->{logfile};
		open(STDERR, ">>".$Conf->{general}->{errlogfile}) if length $Conf->{general}->{errlogfile};
		select((select(STDOUT), $|=1)[0]);
	}
	$loaded == 0 and logger(9,"Configuration file at $confp either doesn't exist or is unreadable/empty.");
	$loaded == -1 and logger(9,"Configuration file at $confp exists but could not be loaded. Please check it is fully-valid YAML.");
	$loaded == -2 and logger(9,"Configuration file at $confp loaded but did not contain any enabled monitors.");
	$loaded == -3 and logger(9,"Configuration file at $confp loaded but was missing a required configuration parameter.");
	#then we run the kernel once, I forget why
	POE::Kernel->run();
	#at this point the config file should be /pretty/ kawaii, so we start initialising
	my $pid = Unix::PID->new()->is_pidfile_running($Conf->{general}->{pidfile}) || 0;
	kill 'HUP', $pid and logger(8, "$ME already running, restarting.") if $pid != $$ and $pid > 0;
	Unix::PID->new()->pid_file($Conf->{general}->{pidfile}) or logger(9, "Failed to write PID to $Conf->{general}->{pidfile}");
	#indicate we should start
	logger(1,"Starting $ME..");
	$running = 1;
	#set up signal handlers so we can handle SIGHUPs and handle quitting gracefully.
	$SIG{HUP} = \&sigtrap;
	$SIG{INT} = \&sigtrap;
	$SIG{QUIT} = \&sigtrap;
	$SIG{TERM} = \&sigtrap;
	#then we initialise monitors
	init_mons();
	logger(1, "$ME version $VERSION started.");
}
sub init_conf {
	$Conf = YAML::LoadFile(shift) or return -1;
	$base = $Conf->{general}->{home} if defined $Conf->{general}->{home} and length $Conf->{general}->{home};
	return -3 unless defined $Conf->{general}->{tmp} and length $Conf->{general}->{tmp};
	$Conf->{general}->{tmp} .= '/' unless $Conf->{general}->{tmp} =~ /\/$/;
	mkdir $Conf->{general}->{tmp} or logger(9,"Error creating work directory $Conf->{general}->{tmp}: $!") unless -d $Conf->{general}->{tmp};
	$Conf->{general}->{storelogs} = 1 unless defined $Conf->{general}->{storelogs} and $Conf->{general}->{storelogs} =~ /^[01]$/;
	$Conf->{general}->{pidfile} = "$base/.$ME.pid" unless exists $Conf->{general}->{pidfile};
	$Conf->{general}->{logfile} = "$base/.$ME.log" unless exists $Conf->{general}->{logfile};
	$Conf->{general}->{errlogfile} = "$base/.$ME.err" unless defined $Conf->{general}->{errlogfile} and length $Conf->{general}->{errlogfile};
	$Conf->{general}->{storelogs} = 0 unless length $Conf->{general}->{logfile} or length $Conf->{general}->{errlogfile};
	return -2 unless scalar keys %{$Conf->{monitor}};
	my $c;
	for my $monitor (keys %{$Conf->{monitor}}) { $c++ unless defined $Conf->{monitor}->{$monitor}->{disable} and $Conf->{monitor}->{$monitor}->{disable} == 1; }
	return -2 unless $c;
}
sub init_mons {
	POE::Session->create( inline_states => { _start => sub {
		foreach our $monitor (keys %{$Conf->{monitor}}) {
			next if defined $Conf->{monitor}->{$monitor}->{disable} and $Conf->{monitor}->{$monitor}->{disable} == 1;
			$Conf->{monitor}->{$monitor}->{poll} = 5 unless defined $Conf->{monitor}->{$monitor}->{poll};
			$Conf->{monitor}->{$monitor}->{ignoreseen} = 0 unless defined $Conf->{monitor}->{$monitor}->{ignoreseen};
			$_[HEAP]->{$monitor} = POE::Component::DirWatch::WithCaller->new(
				alias			=> $monitor,
				directory		=> $Conf->{monitor}->{$monitor}->{dir},
				filter			=> \&filter,
				file_callback	=> \&trigger,
				interval		=> $Conf->{monitor}->{$monitor}->{poll},
				ignore_seen		=> $Conf->{monitor}->{$monitor}->{ignoreseen},
				ensure_seen		=> $Conf->{monitor}->{$monitor}->{ignoreseen},
			);
		}
	}});
}
sub sigtrap {
	my $sig = shift;
	logger(2, "Caught SIG$sig: ".($sig eq 'HUP'? 'Restarting..' : 'Exiting..'));
	$running = 0;
	$sig eq 'HUP' and $sighup = 1;
}
sub logger {
	my ($pri,$msg) = @_;
	print timefmt2str('%e %B %T')." $HOSTNAME $ME\[$$] ($pri): $msg\n" unless $pri =~ /^[29]$/;
	print STDERR timefmt2str('%e %B %T')." $HOSTNAME $ME\[$$] ($pri): $msg\n" if $pri =~ /^[29]$/;
	notify($ME,$msg) if $pri == 3 and $Conf->{general}->{notify}->{on}->{error} == 1;
	exit 0 if $pri == 8;
	exit 1 if $pri == 9;
	return $pri;
}

# Monitor-specific subroutines.
sub filter {
	my ($sender_mon,$file) = @_;
	return 0 if $file->is_dir;
	return $file =~ /$Conf->{monitor}->{$sender_mon}->{match}->{regexp}/ if defined $Conf->{monitor}->{$sender_mon}->{match}->{regexp};
	return 1 if defined $Conf->{monitor}->{$sender_mon}->{match}->{spotlight_meta} and qx(/usr/bin/mdls -name $Conf->{monitor}->{$sender_mon}->{match}->{spotlight_meta} "$file") =~ /^$Conf->{monitor}->{$sender_mon}->{match}->{spotlight_meta} = (?!\(null\)).*$/;
	return 0;
}
sub trigger {
	my ($sender_mon,$file) = @_;
	logger(1,"sender: $sender_mon, file: $file");
	$file->move_to($Conf->{general}->{tmp}.name($sender_mon,$file->basename));
	upload($file) or $file->move_to($Conf->{general}->{tmp}.$file->basename) and return if defined $Conf->{monitor}->{$sender_mon}->{action}->{upload} and $Conf->{monitor}->{$sender_mon}->{action}->{upload} == 1;
	$file->move_to("$Conf->{monitor}->{$sender_mon}->{action}->{target}/".$file->basename) or logger(2,"Couldn't move ".$file->basename." to $Conf->{monitor}->{$sender_mon}->{action}->{target}") if defined $Conf->{monitor}->{$sender_mon}->{action}->{move} and $Conf->{monitor}->{$sender_mon}->{action}->{move} == 1 and defined $Conf->{monitor}->{$sender_mon}->{action}->{target};
	$file->remove() if defined $Conf->{monitor}->{$sender_mon}->{action}->{delete} and $Conf->{monitor}->{$sender_mon}->{action}->{delete} == 1;
}
sub notify {
	macintalk_say(text=>$_[($_[0] eq $ME)? 1 : 0], voice=>(length $Conf->{general}->{notify}->{macintalk_voice}? $Conf->{general}->{notify}->{macintalk_voice} : "Daniel")) if $Conf->{general}->{notify}->{macintalk} == 1;
	nc_notify(@_) if $Conf->{general}->{notify}->{osxnotify} == 1;
}
sub name {
	my ($sender_mon,$filename) = @_;
	$Conf->{monitor}->{$sender_mon}->{action}->{rename} = 1 unless defined $Conf->{monitor}->{$sender_mon}->{action}->{rename};
	return $filename if $Conf->{monitor}->{$sender_mon}->{action}->{rename} =~ /^0$/;
	my $genfilename = timefmt2str($Conf->{general}->{filename});
	return $genfilename."_$filename" if $Conf->{monitor}->{$sender_mon}->{action}->{rename} eq 'prepend';
	$filename =~ s/(\.[a-z0-9]+)$//i and $genfilename .= $1;
	return $filename."_$genfilename" if $Conf->{monitor}->{$sender_mon}->{action}->{rename} eq 'append';
	return $genfilename;
}
sub upload {
	my $file = shift;
	notify("Uploading file","Uploading ".$file->basename." to $Conf->{upload}->{server}.") if $Conf->{general}->{notify}->{on}->{upload} == 1;
	scp_upload($file) or logger(3,"Failed to upload ".$file->basename.".") and return 0;
	clipb_copy("http".(($Conf->{upload}->{pubssl}==1)? 's' : '')."://$Conf->{upload}->{pubdomain}/".($file->basename =~ s/ /%20/r));
	notify("File uploaded",$file->basename." uploaded to $Conf->{upload}->{server}.") if $Conf->{general}->{notify}->{on}->{upload} == 1;
	return 1;
}

# Main
init();
POE::Kernel->run_while(\$running);
logger($sighup? 1 : 8,"Halting $ME..");
exec $^X, $0, @ARGV;
